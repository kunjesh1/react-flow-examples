{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { useReactFlow, useStore } from 'reactflow';\nimport { stratify, tree } from 'd3-hierarchy';\nimport { timer } from 'd3-timer';\n\n// initialize the tree layout (see https://observablehq.com/@d3/tree for examples)\nconst layout = tree()\n// the node size configures the spacing between the nodes ([width, height])\n.nodeSize([200, 150])\n// this is needed for creating equal space between all nodes\n.separation(() => 1);\nconst options = {\n  duration: 300\n};\n\n// the layouting function\n// accepts current nodes and edges and returns the layouted nodes with their updated positions\nfunction layoutNodes(nodes, edges) {\n  // convert nodes and edges into a hierarchical object for using it with the layout function\n  const hierarchy = stratify().id(d => d.id)\n  // get the id of each node by searching through the edges\n  // this only works if every node has one connection\n  .parentId(d => {\n    var _edges$find;\n    return (_edges$find = edges.find(e => e.target === d.id)) === null || _edges$find === void 0 ? void 0 : _edges$find.source;\n  })(nodes);\n\n  // run the layout algorithm with the hierarchy data structure\n  const root = layout(hierarchy);\n\n  // convert the hierarchy back to react flow nodes (the original node is stored as d.data)\n  // we only extract the position from the d3 function\n  return root.descendants().map(d => ({\n    ...d.data,\n    position: {\n      x: d.x,\n      y: d.y\n    }\n  }));\n}\n\n// this is the store selector that is used for triggering the layout, this returns the number of nodes once they change\nconst nodeCountSelector = state => state.nodeInternals.size;\nfunction useLayout() {\n  _s();\n  // this ref is used to fit the nodes in the first run\n  // after first run, this is set to false\n  const initial = useRef(true);\n\n  // we are using nodeCount as the trigger for the re-layouting\n  // whenever the nodes length changes, we calculate the new layout\n  const nodeCount = useStore(nodeCountSelector);\n  const {\n    getNodes,\n    getNode,\n    setNodes,\n    setEdges,\n    getEdges,\n    fitView\n  } = useReactFlow();\n  useEffect(() => {\n    // get the current nodes and edges\n    const nodes = getNodes();\n    const edges = getEdges();\n\n    // run the layout and get back the nodes with their updated positions\n    const targetNodes = layoutNodes(nodes, edges);\n\n    // if you do not want to animate the nodes, you can uncomment the following line\n    // return setNodes(targetNodes);\n\n    // to interpolate and animate the new positions, we create objects that contain the current and target position of each node\n    const transitions = targetNodes.map(node => {\n      var _getNode;\n      return {\n        id: node.id,\n        // this is where the node currently is placed\n        from: ((_getNode = getNode(node.id)) === null || _getNode === void 0 ? void 0 : _getNode.position) || node.position,\n        // this is where we want the node to be placed\n        to: node.position,\n        node\n      };\n    });\n\n    // create a timer to animate the nodes to their new positions\n    const t = timer(elapsed => {\n      const s = elapsed / options.duration;\n      const currNodes = transitions.map(_ref => {\n        let {\n          node,\n          from,\n          to\n        } = _ref;\n        return {\n          id: node.id,\n          position: {\n            // simple linear interpolation\n            x: from.x + (to.x - from.x) * s,\n            y: from.y + (to.y - from.y) * s\n          },\n          data: {\n            ...node.data\n          },\n          type: node.type\n        };\n      });\n      setNodes(currNodes);\n\n      // this is the final step of the animation\n      if (elapsed > options.duration) {\n        // we are moving the nodes to their destination\n        // this needs to happen to avoid glitches\n        const finalNodes = transitions.map(_ref2 => {\n          let {\n            node,\n            to\n          } = _ref2;\n          return {\n            id: node.id,\n            position: {\n              x: to.x,\n              y: to.y\n            },\n            data: {\n              ...node.data\n            },\n            type: node.type\n          };\n        });\n        setNodes(finalNodes);\n\n        // stop the animation\n        t.stop();\n\n        // in the first run, fit the view\n        if (!initial.current) {\n          fitView({\n            duration: 200,\n            padding: 0.2\n          });\n        }\n        initial.current = false;\n      }\n    });\n    return () => {\n      t.stop();\n    };\n  }, [nodeCount, getEdges, getNodes, getNode, setNodes, fitView, setEdges]);\n}\n_s(useLayout, \"zrYtkHcqYIaExcPTXKgkfLp496k=\", false, function () {\n  return [useStore, useReactFlow];\n});\nexport default useLayout;","map":{"version":3,"names":["useEffect","useRef","useReactFlow","useStore","stratify","tree","timer","layout","nodeSize","separation","options","duration","layoutNodes","nodes","edges","hierarchy","id","d","parentId","find","e","target","source","root","descendants","map","data","position","x","y","nodeCountSelector","state","nodeInternals","size","useLayout","initial","nodeCount","getNodes","getNode","setNodes","setEdges","getEdges","fitView","targetNodes","transitions","node","from","to","t","elapsed","s","currNodes","type","finalNodes","stop","current","padding"],"sources":["/Users/kunjeshkumar/Downloads/workflow-builder-example/src/hooks/useLayout.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useReactFlow, useStore, Node, Edge, ReactFlowState } from 'reactflow';\nimport { stratify, tree } from 'd3-hierarchy';\nimport { timer } from 'd3-timer';\n\n// initialize the tree layout (see https://observablehq.com/@d3/tree for examples)\nconst layout = tree<Node>()\n  // the node size configures the spacing between the nodes ([width, height])\n  .nodeSize([200, 150])\n  // this is needed for creating equal space between all nodes\n  .separation(() => 1);\n\nconst options = { duration: 300 };\n\n// the layouting function\n// accepts current nodes and edges and returns the layouted nodes with their updated positions\nfunction layoutNodes(nodes: Node[], edges: Edge[]): Node[] {\n  // convert nodes and edges into a hierarchical object for using it with the layout function\n  const hierarchy = stratify<Node>()\n    .id((d) => d.id)\n    // get the id of each node by searching through the edges\n    // this only works if every node has one connection\n    .parentId((d: Node) => edges.find((e: Edge) => e.target === d.id)?.source)(nodes);\n\n  // run the layout algorithm with the hierarchy data structure\n  const root = layout(hierarchy);\n\n  // convert the hierarchy back to react flow nodes (the original node is stored as d.data)\n  // we only extract the position from the d3 function\n  return root.descendants().map((d) => ({ ...d.data, position: { x: d.x, y: d.y } }));\n}\n\n// this is the store selector that is used for triggering the layout, this returns the number of nodes once they change\nconst nodeCountSelector = (state: ReactFlowState) => state.nodeInternals.size;\n\nfunction useLayout() {\n  // this ref is used to fit the nodes in the first run\n  // after first run, this is set to false\n  const initial = useRef(true);\n\n  // we are using nodeCount as the trigger for the re-layouting\n  // whenever the nodes length changes, we calculate the new layout\n  const nodeCount = useStore(nodeCountSelector);\n\n  const { getNodes, getNode, setNodes, setEdges, getEdges, fitView } = useReactFlow();\n\n  useEffect(() => {\n    // get the current nodes and edges\n    const nodes = getNodes();\n    const edges = getEdges();\n\n    // run the layout and get back the nodes with their updated positions\n    const targetNodes = layoutNodes(nodes, edges);\n\n    // if you do not want to animate the nodes, you can uncomment the following line\n    // return setNodes(targetNodes);\n\n    // to interpolate and animate the new positions, we create objects that contain the current and target position of each node\n    const transitions = targetNodes.map((node) => {\n      return {\n        id: node.id,\n        // this is where the node currently is placed\n        from: getNode(node.id)?.position || node.position,\n        // this is where we want the node to be placed\n        to: node.position,\n        node,\n      };\n    });\n\n    // create a timer to animate the nodes to their new positions\n    const t = timer((elapsed: number) => {\n      const s = elapsed / options.duration;\n\n      const currNodes = transitions.map(({ node, from, to }) => {\n        return {\n          id: node.id,\n          position: {\n            // simple linear interpolation\n            x: from.x + (to.x - from.x) * s,\n            y: from.y + (to.y - from.y) * s,\n          },\n          data: { ...node.data },\n          type: node.type,\n        };\n      });\n\n      setNodes(currNodes);\n\n      // this is the final step of the animation\n      if (elapsed > options.duration) {\n        // we are moving the nodes to their destination\n        // this needs to happen to avoid glitches\n        const finalNodes = transitions.map(({ node, to }) => {\n          return {\n            id: node.id,\n            position: {\n              x: to.x,\n              y: to.y,\n            },\n            data: { ...node.data },\n            type: node.type,\n          };\n        });\n\n        setNodes(finalNodes);\n\n        // stop the animation\n        t.stop();\n\n        // in the first run, fit the view\n        if (!initial.current) {\n          fitView({ duration: 200, padding: 0.2 });\n        }\n        initial.current = false;\n      }\n    });\n\n    return () => {\n      t.stop();\n    };\n  }, [nodeCount, getEdges, getNodes, getNode, setNodes, fitView, setEdges]);\n}\n\nexport default useLayout;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}