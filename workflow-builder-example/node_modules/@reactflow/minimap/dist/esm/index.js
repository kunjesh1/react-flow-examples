import { jsx, jsxs } from 'react/jsx-runtime';
import { memo } from 'react';
import cc from 'classcat';
import shallow from 'zustand/shallow';
import { useStore, Panel, getBoundsOfRects, getRectOfNodes } from '@reactflow/core';

const MiniMapNode = ({ x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, }) => {
    const { background, backgroundColor } = style || {};
    const fill = (color || background || backgroundColor);
    return (jsx("rect", { className: cc(['react-flow__minimap-node', className]), x: x, y: y, rx: borderRadius, ry: borderRadius, width: width, height: height, fill: fill, stroke: strokeColor, strokeWidth: strokeWidth, shapeRendering: shapeRendering }));
};
MiniMapNode.displayName = 'MiniMapNode';
var MiniMapNode$1 = memo(MiniMapNode);

const defaultWidth = 200;
const defaultHeight = 150;
const selector = (s) => {
    const nodes = Array.from(s.nodeInternals.values());
    const viewBB = {
        x: -s.transform[0] / s.transform[2],
        y: -s.transform[1] / s.transform[2],
        width: s.width / s.transform[2],
        height: s.height / s.transform[2],
    };
    return {
        nodes: nodes.filter((node) => !node.hidden && node.width && node.height),
        viewBB,
        boundingRect: nodes.length > 0 ? getBoundsOfRects(getRectOfNodes(nodes), viewBB) : viewBB,
        rfId: s.rfId,
    };
};
const getAttrFunction = (func) => (func instanceof Function ? func : () => func);
const ARIA_LABEL_KEY = 'react-flow__minimap-desc';
function MiniMap({ style, className, nodeStrokeColor = '#555', nodeColor = '#fff', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, maskColor = 'rgb(240, 242, 243, 0.7)', position = 'bottom-right', }) {
    const { boundingRect, viewBB, nodes, rfId } = useStore(selector, shallow);
    const elementWidth = style?.width ?? defaultWidth;
    const elementHeight = style?.height ?? defaultHeight;
    const nodeColorFunc = getAttrFunction(nodeColor);
    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
    const nodeClassNameFunc = getAttrFunction(nodeClassName);
    const scaledWidth = boundingRect.width / elementWidth;
    const scaledHeight = boundingRect.height / elementHeight;
    const viewScale = Math.max(scaledWidth, scaledHeight);
    const viewWidth = viewScale * elementWidth;
    const viewHeight = viewScale * elementHeight;
    const offset = 5 * viewScale;
    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;
    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;
    const width = viewWidth + offset * 2;
    const height = viewHeight + offset * 2;
    const shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';
    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;
    return (jsx(Panel, { position: position, style: style, className: cc(['react-flow__minimap', className]), children: jsxs("svg", { width: elementWidth, height: elementHeight, viewBox: `${x} ${y} ${width} ${height}`, role: "img", "aria-labelledby": labelledBy, children: [jsx("title", { id: labelledBy, children: "React Flow mini map" }), nodes.map((node) => {
                    return (jsx(MiniMapNode$1, { x: node.positionAbsolute?.x ?? 0, y: node.positionAbsolute?.y ?? 0, width: node.width, height: node.height, style: node.style, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering: shapeRendering }, node.id));
                }), jsx("path", { className: "react-flow__minimap-mask", d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fill: maskColor, fillRule: "evenodd" })] }) }));
}
MiniMap.displayName = 'MiniMap';
var MiniMap$1 = memo(MiniMap);

export { MiniMap$1 as MiniMap };
